<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>US Lifestyle Clubs & Dungeons Map</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<style>
/* --- keep most of your original CSS; trimmed here to the important fixes --- */
* { box-sizing: border-box; }
html, body { height:100%; margin:0; padding:0; font-family: 'Inter', sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
body { display:flex; flex-direction:column; }

#searchForm { flex:0 0 auto; padding:12px 16px; background: rgba(44,62,80,0.95); backdrop-filter: blur(10px); box-shadow:0 4px 20px rgba(0,0,0,0.15); border-bottom:2px solid rgba(52,152,219,0.3); display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center; position:relative; }
#map { flex:1 1 auto; width:100%; position:relative; }

/* --- marker wrapper + inner emoji. Important: no transform/animation on wrapper --- */
.marker-wrapper {
  width: 24px;
  height: 24px;
  display: inline-block;
  text-align: center;
  line-height: 24px;
  pointer-events: auto;
  /* DO NOT set transform here ‚Äî Leaflet controls positioning via inline style transform */
}

/* inner emoji element ‚Äî safe to animate because it's a child element */
.marker-emoji {
  display:inline-block;
  font-size:20px;
  position: relative;
  left: 0;
  top: 0;
  /* center the glyph inside the wrapper visually with translate */
  transform: translateY(0);
  will-change: transform;
}

/* a bounce animation applied to the inner emoji only (not the wrapper) */
.marker-emoji.bounce {
  animation: bounce 2000ms infinite;
}

@keyframes bounce {
  0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
  40% { transform: translateY(-8px); }
  60% { transform: translateY(-4px); }
}

/* a couple of classes so you can style differently if you want */
.zip-marker .marker-emoji { /* zip marker styles if needed */ }
.user-marker .marker-emoji { /* user marker styles if needed */ }

/* KEEP your other styling rules from the original file (popups, forms, state labels, etc).
   For brevity they were not duplicated here, but you should keep them in your project.
*/
</style>
</head>
<body>
<div id="searchForm">
    <div class="input-group">
        <input type="text" id="zipInput" placeholder="Enter ZIP code" maxlength="5" pattern="[0-9]{5}">
        <input type="number" id="radiusInput" placeholder="Miles" min="1" max="500" value="50" title="Search radius in miles">
    </div>
    <div class="button-group">
        <button id="searchBtn">Search Nearby</button>
        <button id="geoBtn">Use My Location</button>
        <button id="resetBtn">Reset Search</button>
    </div>
    <div class="input-group radio-group">
        <label><input type="radio" name="filterType" value="all" checked> Clubs & Dungeons</label>
        <label><input type="radio" name="filterType" value="clubs"> Just Clubs</label>
        <label><input type="radio" name="filterType" value="dungeons"> Just Dungeons</label>
    </div>
    <div id="statusMessage"></div>
</div>
<div id="map"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<script>
if (typeof L === 'undefined') {
    document.getElementById('statusMessage').innerHTML = '<div class="error-message">Map library failed to load. Please refresh the page or check your internet connection.</div>';
    throw new Error('Leaflet library not loaded');
}

const isMobile = window.matchMedia("(max-width: 768px)").matches;
const defaultCenter = [39.8283, -98.5795];
const defaultZoom = isMobile ? 3 : 4;

const map = L.map('map', { minZoom: 3, maxZoom: 18, zoomControl: false, attributionControl: false }).setView(defaultCenter, defaultZoom);
L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', { subdomains: 'abcd', maxZoom: 19 }).addTo(map);

// Create custom panes for proper layering
map.createPane('radiusPane');           map.getPane('radiusPane').style.zIndex = 650;
map.createPane('searchMarkersPane');    map.getPane('searchMarkersPane').style.zIndex = 700;

L.control.zoom({ position: 'topleft' }).addTo(map);

/* ---------- variables ---------- */
let clubsByState = {};
let dungeonsByState = {};
let geojsonLayer;
let stateLabels = {};
let currentFilter = 'all';
let searchMarkers = [];
let userLocationMarker = null;
let radiusCircle = null;

/* ---------- helpers (kept your originals) ---------- */
function showMessage(message, type = 'info') {
    const statusEl = document.getElementById('statusMessage');
    statusEl.innerHTML = `<div class="${type}-message">${message}</div>`;
    setTimeout(() => statusEl.innerHTML = '', 5000);
}
function validateZipCode(zip) { return /^\d{5}$/.test(zip); }
function setButtonLoading(buttonId, isLoading) {
    const button = document.getElementById(buttonId);
    button.disabled = isLoading;
    if (isLoading) {
        button.dataset.originalText = button.textContent;
        button.textContent = 'Loading...';
        button.classList.add('loading');
    } else {
        button.textContent = button.dataset.originalText || button.textContent;
        button.classList.remove('loading');
    }
}
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 3959;
    const dLat = toRad(lat2 - lat1);
    const dLng = toRad(lng2 - lng1);
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}
function toRad(deg) { return deg * (Math.PI/180); }

/* ---------- ZIP lookup (unchanged) ---------- */
async function getZipCoordinates(zipCode) {
    try {
        const response = await fetch(`https://api.zippopotam.us/us/${zipCode}`);
        if (!response.ok) {
            throw new Error(response.status === 404 ? 'ZIP code not found' : `API error: ${response.status}`);
        }
        const data = await response.json();
        if (!data.places || data.places.length === 0) throw new Error('No location data found for this ZIP code');
        return { lat: parseFloat(data.places[0].latitude), lng: parseFloat(data.places[0].longitude), city: data.places[0]['place name'], state: data.places[0]['state abbreviation'] };
    } catch (error) {
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
            throw new Error('Network error - please check your internet connection');
        }
        throw error;
    }
}

/* ---------- Reset ---------- */
function resetSearch() {
    searchMarkers.forEach(m => map.removeLayer(m));
    searchMarkers = [];
    if (userLocationMarker) { map.removeLayer(userLocationMarker); userLocationMarker = null; }
    if (radiusCircle) { map.removeLayer(radiusCircle); radiusCircle = null; }
    document.getElementById('zipInput').value = '';
    document.getElementById('radiusInput').value = '50';
    map.setView(defaultCenter, defaultZoom);
    showMessage('Search reset', 'success');
}

/* ---------- Display results (with fixed marker creation) ---------- */
function createDivIcon({ html, className }) {
    // Use a wrapper class for the marker and an inner span for emoji so Leaflet's inline `transform` is NOT overwritten.
    return L.divIcon({
        className: className || 'marker-wrapper',
        html: html,
        iconSize: [24, 24],
        iconAnchor: [12, 24] // bottom center anchor for consistent placement
    });
}

function displaySearchResults(venues, zipCoords, radius, zipCode) {
    // Clear previous
    searchMarkers.forEach(marker => map.removeLayer(marker));
    searchMarkers = [];

    // Add center marker
    const zipHtml = `<div class="marker-wrapper zip-marker"><span class="marker-emoji bounce">üìç</span></div>`;
    const zipMarker = L.marker([zipCoords.lat, zipCoords.lng], {
        icon: createDivIcon({ html: zipHtml, className: 'marker-wrapper zip-marker' }),
        pane: 'searchMarkersPane'
    }).bindPopup(`
        <strong>Search Center</strong><br>
        ${zipCode}<br>
        ${zipCoords.city || ''}${zipCoords.state ? ', ' + zipCoords.state : ''}<br>
        Radius: ${radius} miles
    `).addTo(map);
    searchMarkers.push(zipMarker);
    zipMarker.bringToFront();

    // radius circle
    radiusCircle = L.circle([zipCoords.lat, zipCoords.lng], {
        radius: radius * 1609.34,
        fillColor: '#f8f9fa', fillOpacity: 0.3, color: '#dee2e6', weight: 2, pane: 'radiusPane'
    }).addTo(map);
    searchMarkers.push(radiusCircle);
    radiusCircle.bringToFront();

    // group by coords
    const locationGroups = {};
    venues.forEach(venue => {
        const key = `${venue.lat.toFixed(6)},${venue.lng.toFixed(6)}`;
        if (!locationGroups[key]) locationGroups[key] = [];
        locationGroups[key].push(venue);
    });

    Object.values(locationGroups).forEach(group => {
        const v = group[0];
        let popupContent = '';
        if (group.length === 1) {
            popupContent = `<div class="state-popup-title">Search Result</div>
                <div class="club-list-container"><ul class="club-list">
                    <li class="club-item">
                        <div class="club-name">
                            <a class="club-link" href="${v.url||'#'}" target="_blank" rel="noopener">${v.name}</a>
                            <span class="club-type ${v.type}">${v.type}</span>
                        </div>
                        ${v.city ? `<div class="club-location">${v.city}, ${v.state||''}</div>` : ''}
                        <div class="club-location">Distance: ${v.distance.toFixed(1)} miles</div>
                    </li>
                </ul></div>`;
        } else {
            popupContent = `<div class="state-popup-title">Search Results (${group.length} venues)</div>
                <div class="club-list-container"><ul class="club-list">`;
            group.forEach(venue => {
                popupContent += `<li class="club-item"><div class="club-name">
                    <a class="club-link" href="${venue.url||'#'}" target="_blank" rel="noopener">${venue.name}</a>
                    <span class="club-type ${venue.type}">${venue.type}</span>
                    </div>
                    ${venue.city ? `<div class="club-location">${venue.city}, ${venue.state||''}</div>` : ''}
                </li>`;
            });
            popupContent += `</ul></div>`;
        }

        // marker for the group
        const markerHtml = `<div class="marker-wrapper result-marker"><span class="marker-emoji">${group.length === 1 ? 'üìç' : 'üìå'}</span></div>`;
        const marker = L.marker([v.lat, v.lng], {
            icon: createDivIcon({ html: markerHtml, className: 'marker-wrapper result-marker' }),
            pane: 'searchMarkersPane'
        }).bindPopup(popupContent, { maxWidth: 300 }).addTo(map);
        marker.bringToFront();
        searchMarkers.push(marker);
    });

    // adjust view: if there is more than one thing, fit bounds; if only single center, set a reasonable zoom
    if (searchMarkers.length > 1) {
        const groupFeature = new L.featureGroup(searchMarkers);
        map.fitBounds(groupFeature.getBounds().pad(0.1));
        showMessage(`Found ${venues.length} venue${venues.length !== 1 ? 's' : ''} within ${radius} miles`, 'success');
    } else {
        // only the search center (no results) or a single marker: set view to center + zoom level
        map.setView([zipCoords.lat, zipCoords.lng], 10);
        showMessage(venues.length > 0 ? `Found ${venues.length} venue${venues.length !== 1 ? 's' : ''}` : `No venues found within ${radius} miles of ${zipCode}`, venues.length > 0 ? 'success' : 'error');
    }
}

/* ---------- Load your data and states geojson (kept original promises flow) ---------- */
Promise.all([
    fetch('clubs_geocoded.json').then(res => { if (!res.ok) throw new Error('Failed to load clubs data'); return res.json(); }).catch(() => { showMessage('Warning: Could not load clubs data', 'error'); return {}; }),
    fetch('dungeons_geocoded.json').then(res => { if (!res.ok) throw new Error('Failed to load dungeons data'); return res.json(); }).catch(() => { showMessage('Warning: Could not load dungeons data', 'error'); return {}; })
]).then(([clubsData, dungeonsData]) => {
    clubsByState = clubsData; dungeonsByState = dungeonsData;
    return fetch("https://rawcdn.githack.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json");
}).then(res => { if (!res.ok) throw new Error('Failed to load map data'); return res.json(); })
.then(statesData => {
    geojsonLayer = L.geoJson(statesData, { style: (f) => style(f), onEachFeature }).addTo(map);
    addStateLabels();
    showMessage('Map loaded successfully', 'success');
}).catch(err => { console.error("Error loading data:", err); showMessage('Error loading map data. Please refresh the page.', 'error'); });

/* ---------- state styling, labels etc (kept original logic - omitted here for brevity) ---------- */
function style(feature) {
    const stateName = feature.properties.name;
    const hasClubs = clubsByState[stateName] && clubsByState[stateName].length > 0;
    const hasDungeons = dungeonsByState[stateName] && dungeonsByState[stateName].length > 0;
    let fillColor = "#bdc3c7";
    if (currentFilter === 'all' && (hasClubs || hasDungeons)) fillColor = "#3498db";
    else if (currentFilter === 'clubs' && hasClubs) fillColor = "#3498db";
    else if (currentFilter === 'dungeons' && hasDungeons) fillColor = "#3498db";
    return { fillColor, weight: 2, opacity: 1, color: "white", dashArray: "3", fillOpacity: 0.7 };
}
function highlightFeature(e) { const layer = e.target; layer.setStyle({ weight: 3, color: "#666", dashArray: "", fillOpacity: 0.9 }); layer.bringToFront(); if (radiusCircle) radiusCircle.bringToFront(); }
function resetHighlight(e) { if (geojsonLayer) geojsonLayer.resetStyle(e.target); }
function onEachFeature(feature, layer) {
    const stateName = feature.properties.name;
    layer.on({ mouseover: highlightFeature, mouseout: resetHighlight, click: () => layer.bindPopup(generatePopup(stateName), { maxWidth: 350 }).openPopup() });
}
function generatePopup(stateName) {
    const clubs = clubsByState[stateName] || [];
    const dungeons = dungeonsByState[stateName] || [];
    let popupContent = `<div class="state-popup-title">${stateName}</div>`;
    if ((currentFilter === 'clubs' && clubs.length === 0) || (currentFilter === 'dungeons' && dungeons.length === 0) || (currentFilter === 'all' && clubs.length === 0 && dungeons.length === 0)) {
        popupContent += `<div class="no-clubs">No listings</div>`;
    } else {
        popupContent += `<div class="club-list-container"><ul class="club-list">`;
        if (currentFilter !== 'dungeons') clubs.forEach(c => { popupContent += `<li class="club-item"><div class="club-name"><a class="club-link" href="${c.url||'#'}" target="_blank" rel="noopener">${c.name}</a><span class="club-type">club</span></div>${c.city ? `<div class="club-location">${c.city}, ${c.state}</div>` : ''}</li>`; });
        if (currentFilter !== 'clubs') dungeons.forEach(d => { popupContent += `<li class="club-item"><div class="club-name"><a class="club-link" href="${d.url||'#'}" target="_blank" rel="noopener">${d.name}</a><span class="club-type dungeon">dungeon</span></div>${d.city ? `<div class="club-location">${d.city}, ${d.state}</div>` : ''}</li>`; });
        popupContent += `</ul></div>`;
    }
    return popupContent;
}

/* ---------- Add state labels (kept original) ---------- */
function addStateLabels() {
    if (!geojsonLayer) return;
    geojsonLayer.eachLayer(layer => {
        const stateName = layer.feature.properties.name;
        let c = layer.getBounds().getCenter();
        if (stateName === 'Idaho') c = L.latLng(c.lat - 0.5, c.lng - 0.8);
        const label = L.marker([c.lat, c.lng], {
            icon: L.divIcon({ className: 'state-label hidden', html: stateName, iconSize: [0,0], iconAnchor:[0,0] }),
            interactive: false
        }).addTo(map);
        stateLabels[stateName] = label;
    });
}

/* ---------- UI wiring: filter, search, geolocate, reset ---------- */
document.querySelectorAll('input[name="filterType"]').forEach(radio => {
    radio.addEventListener('change', e => {
        currentFilter = e.target.value;
        if (geojsonLayer) geojsonLayer.eachLayer(layer => layer.setStyle(style(layer.feature)));
    });
});

document.getElementById('searchBtn').addEventListener('click', async () => {
    const zipCode = document.getElementById('zipInput').value.trim();
    const radius = parseFloat(document.getElementById('radiusInput').value) || 50;
    if (!zipCode) { showMessage('Please enter a ZIP code to search.', 'error'); return; }
    if (!validateZipCode(zipCode)) { showMessage('Please enter a valid 5-digit ZIP code.', 'error'); return; }
    if (radius < 1 || radius > 500) { showMessage('Please enter a radius between 1 and 500 miles.', 'error'); return; }
    setButtonLoading('searchBtn', true);
    try {
        const zipCoords = await getZipCoordinates(zipCode);
        const nearbyVenues = [];
        if (currentFilter === 'all' || currentFilter === 'clubs') {
            Object.values(clubsByState).flat().forEach(club => {
                if (club.lat && club.lng) {
                    const distance = calculateDistance(zipCoords.lat, zipCoords.lng, club.lat, club.lng);
                    if (distance <= radius) nearbyVenues.push({...club, distance, type:'club'});
                }
            });
        }
        if (currentFilter === 'all' || currentFilter === 'dungeons') {
            Object.values(dungeonsByState).flat().forEach(dungeon => {
                if (dungeon.lat && dungeon.lng) {
                    const distance = calculateDistance(zipCoords.lat, zipCoords.lng, dungeon.lat, dungeon.lng);
                    if (distance <= radius) nearbyVenues.push({...dungeon, distance, type:'dungeon'});
                }
            });
        }
        nearbyVenues.sort((a,b)=>a.distance - b.distance);
        displaySearchResults(nearbyVenues, zipCoords, radius, zipCode);
    } catch (error) {
        showMessage(`Error: ${error.message}`, 'error');
    } finally {
        setButtonLoading('searchBtn', false);
    }
});

document.getElementById('geoBtn').addEventListener('click', () => {
    if (!navigator.geolocation) { showMessage("Geolocation is not supported by your browser.", 'error'); return; }
    setButtonLoading('geoBtn', true);
    navigator.geolocation.getCurrentPosition(async pos => {
        const lat = pos.coords.latitude, lng = pos.coords.longitude, radius = parseFloat(document.getElementById('radiusInput').value) || 50;
        if (userLocationMarker) map.removeLayer(userLocationMarker);
        const userHtml = `<div class="marker-wrapper user-marker"><span class="marker-emoji bounce">üéØ</span></div>`;
        userLocationMarker = L.marker([lat,lng], { icon: createDivIcon({ html: userHtml, className: 'marker-wrapper user-marker' }), pane: 'searchMarkersPane' }).bindPopup("You are here!").addTo(map);
        userLocationMarker.bringToFront();

        const nearbyVenues = [];
        if (currentFilter === 'all' || currentFilter === 'clubs') {
            Object.values(clubsByState).flat().forEach(club => {
                if (club.lat && club.lng) {
                    const distance = calculateDistance(lat, lng, club.lat, club.lng);
                    if (distance <= radius) nearbyVenues.push({...club, distance, type:'club'});
                }
            });
        }
        if (currentFilter === 'all' || currentFilter === 'dungeons') {
            Object.values(dungeonsByState).flat().forEach(dungeon => {
                if (dungeon.lat && dungeon.lng) {
                    const distance = calculateDistance(lat, lng, dungeon.lat, dungeon.lng);
                    if (distance <= radius) nearbyVenues.push({...dungeon, distance, type:'dungeon'});
                }
            });
        }
        nearbyVenues.sort((a,b)=>a.distance - b.distance);
        const coords = { lat, lng, city: 'Your Location', state: '' };
        displaySearchResults(nearbyVenues, coords, radius, 'Your Location');
        setButtonLoading('geoBtn', false);
    }, err => {
        let errorMessage = "Error getting location: ";
        switch(err.code) {
            case err.PERMISSION_DENIED: errorMessage += "Permission denied"; break;
            case err.POSITION_UNAVAILABLE: errorMessage += "Position unavailable"; break;
            case err.TIMEOUT: errorMessage += "Request timeout"; break;
            default: errorMessage += "Unknown error"; break;
        }
        showMessage(errorMessage, 'error');
        setButtonLoading('geoBtn', false);
    }, { timeout: 10000, enableHighAccuracy: true });
});

document.getElementById('resetBtn').addEventListener('click', resetSearch);

document.getElementById('zipInput').addEventListener('input', function() { this.value = this.value.replace(/\D/g, '').slice(0,5); });
document.getElementById('zipInput').addEventListener('keypress', function(e) { if (e.key === 'Enter') document.getElementById('searchBtn').click(); });

</script>
</body>
</html>
