<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>US Lifestyle Clubs & Dungeons Map</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<style>
html, body { height: 100%; margin: 0; padding: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
body { display: flex; flex-direction: column; }
#searchForm {
    flex: 0 0 auto;
    padding: 15px;
    background: #2c3e50;
    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    align-items: center;
}
.input-group { display: flex; gap: 10px; align-items: center; }
#searchForm input { padding: 12px; border: 1px solid #ddd; border-radius: 6px; font-size: 16px; min-width: 180px; }
#radiusInput { width: 100px; }
#searchForm button { padding: 12px 20px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; transition: background 0.2s; font-size: 16px; font-weight: 500; }
#searchForm button:hover { background: #2980b9; }
#searchForm button:disabled { background: #95a5a6; cursor: not-allowed; }
#searchForm button#geoBtn { background: #27ae60; }
#searchForm button#geoBtn:hover { background: #219653; }
#searchForm button#resetBtn { background: #e74c3c; }
#searchForm button#resetBtn:hover { background: #c0392b; }
#searchForm label { color: white; font-size: 14px; }
#searchForm input[type="radio"] { margin-right: 5px; }
#map { flex: 1 1 auto; width: 100%; }
.loading { opacity: 0.7; }
.error-message { color: #e74c3c; background: rgba(231, 76, 60, 0.1); padding: 8px; border-radius: 4px; margin: 5px 0; }
.success-message { color: #27ae60; background: rgba(39, 174, 96, 0.1); padding: 8px; border-radius: 4px; margin: 5px 0; }

.leaflet-control-reset {
    background: white;
    padding: 10px 15px;
    cursor: pointer;
    border-radius: 4px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.4);
    font-size: 16px;
    font-weight: bold;
    text-align: center;
    margin-bottom: 10px;
    border: 2px solid rgba(0,0,0,0.2);
}
.leaflet-control-reset:hover { background: #f8f8f8; }
.state-label {
    font-weight: bold;
    color: #2c3e50;
    text-shadow: 1px 1px 3px white, -1px -1px 3px white, 1px -1px 3px white, -1px 1px 3px white;
    pointer-events: none;
    text-align: center;
    white-space: nowrap;
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: font-size 0.4s ease, color 0.3s ease;
}
.state-label.hidden { display: none; }
.state-label.highlight { color: #e74c3c; font-weight: 900; }
.leaflet-popup-content-wrapper { border-radius: 8px; padding: 2px; background: #f8f9fa; box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3); }
.leaflet-popup-content { margin: 18px; font-size: 18px; line-height: 1.5; min-width: 250px; }
.state-popup-title { font-size: 22px; font-weight: bold; color: #2c3e50; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 2px solid #3498db; text-align: center; }
.club-list-container { max-height: 220px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; background: #fff; padding: 5px; }
.club-list { list-style-type: none; padding: 0; margin: 0; }
.club-item { padding: 12px 0; border-bottom: 1px solid #e0e0e0; }
.club-item:last-child { border-bottom: none; }
.club-name { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
.club-link { color: #2980b9; text-decoration: none; font-weight: 500; padding: 6px 10px; border-radius: 4px; transition: background 0.2s; flex: 1; }
.club-link:hover { background: #e8f4fd; color: #e74c3c; }
.club-location { font-size: 14px; color: #7f8c8d; margin-left: 10px; font-style: italic; }
.club-type { font-size: 12px; background: #f39c12; color: white; padding: 2px 6px; border-radius: 3px; margin-left: 8px; }
.club-type.dungeon { background: #34495e; color: #ff6b6b; }
.no-clubs { font-style: italic; color: #7f8c8d; text-align: center; padding: 15px 0; font-size: 16px; }
.leaflet-control-attribution { display: none !important; }

@media (max-width: 768px) {
    #searchForm { flex-direction: column; align-items: stretch; padding: 8px; gap: 8px; }
    .input-group { width: 100%; flex-direction: row; gap: 8px; }
    #searchForm input { min-width: auto; padding: 10px; font-size: 14px; flex: 1; }
    #zipInput { flex: 2; }
    #radiusInput { width: 80px; flex: none; }
    .button-group { display: flex; width: 100%; gap: 8px; }
    #searchForm button { padding: 10px 12px; font-size: 14px; flex: 1; }
    .state-label { font-size: 10px; }
    .leaflet-popup-content { font-size: 16px; min-width: 200px; }
    .state-popup-title { font-size: 20px; }
    .club-name { flex-direction: row; align-items: center; justify-content: space-between; }
    .club-type { margin-left: 8px; margin-top: 0; }
    .club-location { margin-left: 0; margin-top: 2px; }
}
</style>
</head>
<body>
<div id="searchForm">
    <div class="input-group">
        <input type="text" id="zipInput" placeholder="Enter ZIP code" maxlength="5" pattern="[0-9]{5}">
        <input type="number" id="radiusInput" placeholder="Miles" min="1" max="500" value="50" title="Search radius in miles">
    </div>
    <div class="button-group">
        <button id="searchBtn">Search Nearby</button>
        <button id="geoBtn">Use My Location</button>
        <button id="resetBtn">Reset Search</button>
    </div>
    <div class="input-group">
        <label><input type="radio" name="filterType" value="all" checked> Clubs & Dungeons</label>
        <label><input type="radio" name="filterType" value="clubs"> Just Clubs</label>
        <label><input type="radio" name="filterType" value="dungeons"> Just Dungeons</label>
    </div>
    <div id="statusMessage"></div>
</div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const isMobile = window.matchMedia("(max-width: 768px)").matches;
const defaultCenter = [39.8283, -98.5795];
const defaultZoom = isMobile ? 3 : 4;

const map = L.map('map', { minZoom: 3, maxZoom: 18, zoomControl: false, attributionControl: false }).setView(defaultCenter, defaultZoom);
L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', { subdomains: 'abcd', maxZoom: 19 }).addTo(map);

const ResetControl = L.Control.extend({
    options: { position: 'topleft' },
    onAdd: function(map) {
        const container = L.DomUtil.create('div', 'leaflet-control-reset');
        container.innerHTML = 'Reset View';
        L.DomEvent.on(container, 'click', e => { L.DomEvent.stopPropagation(e); resetSearch(); });
        return container;
    }
});
map.addControl(new ResetControl());
L.control.zoom({ position: 'topleft' }).addTo(map);

let clubsByState = {};
let dungeonsByState = {};
let geojsonLayer;
let stateLabels = {};
let currentFilter = 'all';
let searchMarkers = [];
let userLocationMarker = null;

// Utility functions
function showMessage(message, type = 'info') {
    const statusEl = document.getElementById('statusMessage');
    statusEl.innerHTML = `<div class="${type}-message">${message}</div>`;
    setTimeout(() => statusEl.innerHTML = '', 5000);
}

function validateZipCode(zip) {
    const zipPattern = /^\d{5}$/;
    return zipPattern.test(zip);
}

function setButtonLoading(buttonId, isLoading) {
    const button = document.getElementById(buttonId);
    button.disabled = isLoading;
    if (isLoading) {
        button.dataset.originalText = button.textContent;
        button.textContent = 'Loading...';
        button.classList.add('loading');
    } else {
        button.textContent = button.dataset.originalText || button.textContent;
        button.classList.remove('loading');
    }
}

// Distance calculation functions
function calculateDistance(lat1, lng1, lat2, lng2) {
    const R = 3959; // Earth's radius in miles
    const dLat = toRad(lat2 - lat1);
    const dLng = toRad(lng2 - lng1);
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
}

function toRad(degrees) {
    return degrees * (Math.PI/180);
}

// ZIP code coordinate lookup with better error handling
async function getZipCoordinates(zipCode) {
    try {
        // Use HTTPS to avoid mixed content issues
        const response = await fetch(`https://api.zippopotam.us/us/${zipCode}`);
        if (!response.ok) {
            throw new Error(response.status === 404 ? 'ZIP code not found' : `API error: ${response.status}`);
        }
        const data = await response.json();
        
        if (!data.places || data.places.length === 0) {
            throw new Error('No location data found for this ZIP code');
        }
        
        return {
            lat: parseFloat(data.places[0].latitude),
            lng: parseFloat(data.places[0].longitude),
            city: data.places[0]['place name'],
            state: data.places[0]['state abbreviation']
        };
    } catch (error) {
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
            throw new Error('Network error - please check your internet connection');
        }
        throw error;
    }
}

// Reset search function
function resetSearch() {
    searchMarkers.forEach(marker => map.removeLayer(marker));
    searchMarkers = [];
    if (userLocationMarker) {
        map.removeLayer(userLocationMarker);
        userLocationMarker = null;
    }
    
    // Reset form inputs
    document.getElementById('zipInput').value = '';
    document.getElementById('radiusInput').value = '50';
    
    map.setView(defaultCenter, defaultZoom);
    updateLabelSizes();
    showMessage('Search reset', 'success');
}

// Improved search results display
function displaySearchResults(venues, zipCoords, radius, zipCode) {
    // Clear previous search markers
    searchMarkers.forEach(marker => map.removeLayer(marker));
    searchMarkers = [];

    // Add ZIP code marker with better popup
    const zipMarker = L.marker([zipCoords.lat, zipCoords.lng], {
        icon: L.divIcon({
            className: 'zip-marker',
            html: 'üìç',
            iconSize: [20, 20],
            iconAnchor: [10, 10]
        })
    }).bindPopup(`
        <strong>Search Center</strong><br>
        ${zipCode}<br>
        ${zipCoords.city}, ${zipCoords.state}<br>
        Radius: ${radius} miles
    `).addTo(map);
    searchMarkers.push(zipMarker);

    // Add radius circle
    const radiusCircle = L.circle([zipCoords.lat, zipCoords.lng], {
        radius: radius * 1609.34, // Convert miles to meters
        fillColor: '#3498db',
        fillOpacity: 0.1,
        color: '#3498db',
        weight: 2
    }).addTo(map);
    searchMarkers.push(radiusCircle);

    // Group venues by location to handle multiple venues at same location
    const locationGroups = {};
    venues.forEach(venue => {
        const key = `${venue.lat},${venue.lng}`;
        if (!locationGroups[key]) {
            locationGroups[key] = [];
        }
        locationGroups[key].push(venue);
    });

    // Add markers for each location group
    Object.values(locationGroups).forEach(venueGroup => {
        const firstVenue = venueGroup[0];
        let popupContent = '';
        
        if (venueGroup.length === 1) {
            const venue = venueGroup[0];
            const location = (venue.city && venue.state) ? `${venue.city}, ${venue.state}` : (venue.state || '');
            popupContent = `
                <div class="state-popup-title">Search Result</div>
                <div class="club-list-container">
                    <ul class="club-list">
                        <li class="club-item">
                            <div class="club-name">
                                <a class="club-link" href="${venue.url||'#'}" target="_blank" rel="noopener">${venue.name}</a>
                                <span class="club-type ${venue.type}">${venue.type}</span>
                            </div>
                            ${location ? `<div class="club-location">${location}</div>` : ''}
                            <div class="club-location">Distance: ${venue.distance.toFixed(1)} miles</div>
                        </li>
                    </ul>
                </div>
            `;
        } else {
            popupContent = `
                <div class="state-popup-title">Search Results (${venueGroup.length} venues)</div>
                <div class="club-list-container">
                    <ul class="club-list">
            `;
            venueGroup.forEach(venue => {
                const location = (venue.city && venue.state) ? `${venue.city}, ${venue.state}` : (venue.state || '');
                popupContent += `
                    <li class="club-item">
                        <div class="club-name">
                            <a class="club-link" href="${venue.url||'#'}" target="_blank" rel="noopener">${venue.name}</a>
                            <span class="club-type ${venue.type}">${venue.type}</span>
                        </div>
                        ${location ? `<div class="club-location">${location}</div>` : ''}
                    </li>
                `;
            });
            popupContent += `
                    </ul>
                    <div style="text-align: center; margin-top: 10px; font-style: italic; color: #7f8c8d;">
                        Distance: ${firstVenue.distance.toFixed(1)} miles
                    </div>
                </div>
            `;
        }

        const marker = L.marker([firstVenue.lat, firstVenue.lng])
            .bindPopup(popupContent, { maxWidth: 300 })
            .addTo(map);
        searchMarkers.push(marker);
    });

    // Fit map to show all results with padding
    if (venues.length > 0) {
        const group = new L.featureGroup(searchMarkers);
        map.fitBounds(group.getBounds().pad(0.1));
        showMessage(`Found ${venues.length} venue${venues.length !== 1 ? 's' : ''} within ${radius} miles`, 'success');
    } else {
        map.setView([zipCoords.lat, zipCoords.lng], 10);
        showMessage(`No venues found within ${radius} miles of ${zipCode}`, 'error');
    }
}

// Load data with better error handling
Promise.all([
    fetch('clubs_geocoded.json').then(res => {
        if (!res.ok) throw new Error('Failed to load clubs data');
        return res.json();
    }).catch(() => {
        showMessage('Warning: Could not load clubs data', 'error');
        return {};
    }),
    fetch('dungeons_geocoded.json').then(res => {
        if (!res.ok) throw new Error('Failed to load dungeons data');
        return res.json();
    }).catch(() => {
        showMessage('Warning: Could not load dungeons data', 'error');
        return {};
    })
]).then(([clubsData, dungeonsData]) => {
    clubsByState = clubsData;
    dungeonsByState = dungeonsData;
    return fetch("https://rawcdn.githack.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json");
}).then(res => {
    if (!res.ok) throw new Error('Failed to load map data');
    return res.json();
}).then(statesData => {
    geojsonLayer = L.geoJson(statesData, { style, onEachFeature }).addTo(map);
    addStateLabels();
    updateLabelSizes();
    showMessage('Map loaded successfully', 'success');
}).catch(err => {
    console.error("Error loading data:", err);
    showMessage('Error loading map data. Please refresh the page.', 'error');
});

function style(feature) {
    const stateName = feature.properties.name;
    const hasClubs = clubsByState[stateName] && clubsByState[stateName].length > 0;
    const hasDungeons = dungeonsByState[stateName] && dungeonsByState[stateName].length > 0;
    let fillColor = "#bdc3c7";
    if (currentFilter === 'all' && (hasClubs || hasDungeons)) fillColor = "#3498db";
    else if (currentFilter === 'clubs' && hasClubs) fillColor = "#3498db";
    else if (currentFilter === 'dungeons' && hasDungeons) fillColor = "#3498db";
    return { fillColor, weight: 2, opacity: 1, color: "white", dashArray: "3", fillOpacity: 0.7 };
}

function highlightFeature(e) {
    const layer = e.target;
    layer.setStyle({ weight: 3, color: "#666", dashArray: "", fillOpacity: 0.9 });
    layer.bringToFront();
    const stateName = layer.feature.properties.name;
    if (stateLabels[stateName]) stateLabels[stateName].getElement().classList.add('highlight');
}

function resetHighlight(e) {
    geojsonLayer.resetStyle(e.target);
    const stateName = e.target.feature.properties.name;
    if (stateLabels[stateName]) stateLabels[stateName].getElement().classList.remove('highlight');
}

function onEachFeature(feature, layer) {
    const stateName = feature.properties.name;
    layer.on({
        mouseover: highlightFeature,
        mouseout: resetHighlight,
        click: () => layer.bindPopup(generatePopup(stateName), { maxWidth: 350 }).openPopup()
    });
}

function generatePopup(stateName) {
    const clubs = clubsByState[stateName] || [];
    const dungeons = dungeonsByState[stateName] || [];
    let popupContent = `<div class="state-popup-title">${stateName}</div>`;

    if ((currentFilter === 'clubs' && clubs.length === 0) ||
        (currentFilter === 'dungeons' && dungeons.length === 0) ||
        (currentFilter === 'all' && clubs.length === 0 && dungeons.length === 0)) {
        popupContent += `<div class="no-clubs">No listings</div>`;
    } else {
        popupContent += `<div class="club-list-container"><ul class="club-list">`;
        if (currentFilter !== 'dungeons') {
            clubs.forEach(c => {
                const location = (c.city && c.state) ? `${c.city}, ${c.state}` : (c.state || '');
                popupContent += `
                    <li class="club-item">
                        <div class="club-name">
                            <a class="club-link" href="${c.url||'#'}" target="_blank" rel="noopener">${c.name}</a>
                            <span class="club-type">club</span>
                        </div>
                        ${location ? `<div class="club-location">${location}</div>` : ''}
                    </li>
                `;
            });
        }
        if (currentFilter !== 'clubs') {
            dungeons.forEach(d => {
                const location = (d.city && d.state) ? `${d.city}, ${d.state}` : (d.state || '');
                popupContent += `
                    <li class="club-item">
                        <div class="club-name">
                            <a class="club-link" href="${d.url||'#'}" target="_blank" rel="noopener">${d.name}</a>
                            <span class="club-type dungeon">dungeon</span>
                        </div>
                        ${location ? `<div class="club-location">${location}</div>` : ''}
                    </li>
                `;
            });
        }
        popupContent += `</ul></div>`;
    }
    return popupContent;
}

function addStateLabels() {
    if (!geojsonLayer) return;
    geojsonLayer.eachLayer(layer => {
        const stateName = layer.feature.properties.name;
        const c = layer.getBounds().getCenter();
        const label = L.marker([c.lat, c.lng], {
            icon: L.divIcon({ 
                className: 'state-label hidden', 
                html: stateName, 
                iconSize: [0, 0], 
                iconAnchor: [0, 0] 
            }),
            interactive: false
        }).addTo(map);
        stateLabels[stateName] = label;
    });
}

function updateLabelSizes() {
    const zoom = map.getZoom();
    Object.entries(stateLabels).forEach(([stateName, label]) => {
        const el = label.getElement();
        if (!el) return;
        if (zoom <= (isMobile ? 3 : 4)) {
            el.classList.add('hidden');
        } else {
            el.classList.remove('hidden');
            el.style.fontSize = `${Math.max(8, Math.min(24, zoom * 2))}px`;
        }
    });
}

// Event listeners with improved validation
document.querySelectorAll('input[name="filterType"]').forEach(radio => {
    radio.addEventListener('change', e => {
        currentFilter = e.target.value;
        if (geojsonLayer) {
            geojsonLayer.eachLayer(layer => layer.setStyle(style(layer.feature)));
        }
    });
});

document.getElementById('searchBtn').addEventListener('click', async () => {
    const zipCode = document.getElementById('zipInput').value.trim();
    const radius = parseFloat(document.getElementById('radiusInput').value) || 50;
    
    if (!zipCode) {
        showMessage('Please enter a ZIP code to search.', 'error');
        return;
    }
    
    if (!validateZipCode(zipCode)) {
        showMessage('Please enter a valid 5-digit ZIP code.', 'error');
        return;
    }
    
    if (radius < 1 || radius > 500) {
        showMessage('Please enter a radius between 1 and 500 miles.', 'error');
        return;
    }
    
    setButtonLoading('searchBtn', true);
    
    try {
        const zipCoords = await getZipCoordinates(zipCode);
        const nearbyVenues = [];
        
        // Search clubs
        if (currentFilter === 'all' || currentFilter === 'clubs') {
            Object.values(clubsByState).flat().forEach(club => {
                if (club.lat && club.lng) {
                    const distance = calculateDistance(zipCoords.lat, zipCoords.lng, club.lat, club.lng);
                    if (distance <= radius) {
                        nearbyVenues.push({...club, distance, type: 'club'});
                    }
                }
            });
        }
        
        // Search dungeons
        if (currentFilter === 'all' || currentFilter === 'dungeons') {
            Object.values(dungeonsByState).flat().forEach(dungeon => {
                if (dungeon.lat && dungeon.lng) {
                    const distance = calculateDistance(zipCoords.lat, zipCoords.lng, dungeon.lat, dungeon.lng);
                    if (distance <= radius) {
                        nearbyVenues.push({...dungeon, distance, type: 'dungeon'});
                    }
                }
            });
        }
        
        nearbyVenues.sort((a, b) => a.distance - b.distance);
        displaySearchResults(nearbyVenues, zipCoords, radius, zipCode);
        
    } catch (error) {
        showMessage(`Error: ${error.message}`, 'error');
    } finally {
        setButtonLoading('searchBtn', false);
    }
});

document.getElementById('geoBtn').addEventListener('click', () => {
    if (!navigator.geolocation) {
        showMessage("Geolocation is not supported by your browser.", 'error');
        return;
    }
    
    setButtonLoading('geoBtn', true);
    
    navigator.geolocation.getCurrentPosition(
        async pos => {
            const lat = pos.coords.latitude;
            const lng = pos.coords.longitude;
            const radius = parseFloat(document.getElementById('radiusInput').value) || 50;
            
            // Remove previous user location marker
            if (userLocationMarker) {
                map.removeLayer(userLocationMarker);
            }
            
            userLocationMarker = L.marker([lat, lng], {
                icon: L.divIcon({
                    className: 'user-location-marker',
                    html: 'üìç',
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                })
            }).bindPopup("You are here!").addTo(map);
            
            // Perform search from user location
            const nearbyVenues = [];
            
            // Search clubs
            if (currentFilter === 'all' || currentFilter === 'clubs') {
                Object.values(clubsByState).flat().forEach(club => {
                    if (club.lat && club.lng) {
                        const distance = calculateDistance(lat, lng, club.lat, club.lng);
                        if (distance <= radius) {
                            nearbyVenues.push({...club, distance, type: 'club'});
                        }
                    }
                });
            }
            
            // Search dungeons
            if (currentFilter === 'all' || currentFilter === 'dungeons') {
                Object.values(dungeonsByState).flat().forEach(dungeon => {
                    if (dungeon.lat && dungeon.lng) {
                        const distance = calculateDistance(lat, lng, dungeon.lat, dungeon.lng);
                        if (distance <= radius) {
                            nearbyVenues.push({...dungeon, distance, type: 'dungeon'});
                        }
                    }
                });
            }
            
            nearbyVenues.sort((a, b) => a.distance - b.distance);
            
            // Create coordinates object for display function
            const coords = { lat, lng, city: 'Your Location', state: '' };
            
            displaySearchResults(nearbyVenues, coords, radius, 'Your Location');
            setButtonLoading('geoBtn', false);
        },
        err => {
            let errorMessage = "Error getting location: ";
            switch(err.code) {
                case err.PERMISSION_DENIED:
                    errorMessage += "Permission denied";
                    break;
                case err.POSITION_UNAVAILABLE:
                    errorMessage += "Position unavailable";
                    break;
                case err.TIMEOUT:
                    errorMessage += "Request timeout";
                    break;
                default:
                    errorMessage += "Unknown error";
                    break;
            }
            showMessage(errorMessage, 'error');
            setButtonLoading('geoBtn', false);
        },
        { timeout: 10000, enableHighAccuracy: true }
    );
});

document.getElementById('resetBtn').addEventListener('click', resetSearch);

// Input validation
document.getElementById('zipInput').addEventListener('input', function(e) {
    // Only allow numbers
    this.value = this.value.replace(/\D/g, '');
    // Limit to 5 digits
    if (this.value.length > 5) {
        this.value = this.value.slice(0, 5);
    }
});

// Allow Enter key to trigger search
document.getElementById('zipInput').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
        document.getElementById('searchBtn').click();
    }
});

updateLabelSizes();
map.on('zoomend', updateLabelSizes);
</script>
</body>
</html>
